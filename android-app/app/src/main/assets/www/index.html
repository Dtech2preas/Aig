<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D-TECH ANIME</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-blue: #1a73e8;
            --dark-blue: #0d47a1;
            --dark-bg: #121212;
            --card-bg: #1e1e1e;
            --text-light: #f5f5f5;
            --text-muted: #b0b0b0;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text-light);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
        }

        .hero-section {
            background: linear-gradient(135deg, var(--dark-blue) 0%, var(--dark-bg) 100%);
            padding: 2rem 0;
            margin-bottom: 1.5rem;
            border-radius: 0 0 1rem 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .search-box { max-width: 600px; margin: 0 auto; }
        .search-box input {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-light);
        }
        .search-box button { background-color: var(--primary-blue); border-color: var(--primary-blue); }

        .section-title {
            border-left: 4px solid var(--primary-blue);
            padding-left: 0.8rem;
            margin: 1.5rem 0 1rem 0;
            font-size: 1.3rem;
            font-weight: 700;
        }

        /* --- HORIZONTAL SCROLL --- */
        .media-scroller {
            display: grid;
            grid-auto-flow: column;
            grid-auto-columns: 160px;
            gap: 1rem;
            overflow-x: auto;
            overscroll-behavior-inline: contain;
            padding-bottom: 1rem;
            padding-left: 5px;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-blue) var(--card-bg);
        }
        @media (min-width: 768px) { .media-scroller { grid-auto-columns: 200px; } }

        .media-scroller::-webkit-scrollbar { height: 6px; }
        .media-scroller::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 10px; }
        .media-scroller::-webkit-scrollbar-thumb { background: var(--primary-blue); border-radius: 10px; }

        /* --- CARDS --- */
        .anime-card-compact {
            background-color: transparent;
            border: none;
            position: relative;
            transition: transform 0.2s;
            display: flex;
            flex-direction: column;
            height: 100%;
            text-decoration: none;
            color: inherit;
            cursor: pointer;
        }
        .anime-card-compact:hover { transform: translateY(-3px); color: var(--primary-blue); }

        .cover-wrapper {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 2/3;
            margin-bottom: 0.5rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .anime-cover { width: 100%; height: 100%; object-fit: cover; }

        .overlay-ep {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding: 20px 8px 5px 8px;
            display: flex; justify-content: space-between; align-items: flex-end;
        }
        .ep-badge {
            background-color: var(--primary-blue); color: white;
            font-size: 0.75rem; padding: 2px 6px; border-radius: 4px; font-weight: bold;
        }

        .play-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.4);
            display: flex; align-items: center; justify-content: center;
            opacity: 0; transition: opacity 0.2s;
        }
        .cover-wrapper:hover .play-overlay { opacity: 1; }

        /* History Specific */
        .history-actions {
            position: absolute; top: 5px; right: 5px; z-index: 10;
        }
        .btn-list-view {
            background: rgba(0,0,0,0.7); color: white;
            border: 1px solid rgba(255,255,255,0.3);
            width: 30px; height: 30px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.8rem; transition: all 0.2s;
        }
        .btn-list-view:hover { background: var(--primary-blue); border-color: var(--primary-blue); }

        .watched-time {
            position: absolute; top: 5px; left: 5px;
            background: rgba(0,0,0,0.7); color: #ccc;
            font-size: 0.65rem; padding: 2px 6px; border-radius: 4px;
        }

        .compact-title {
            font-size: 0.9rem; font-weight: 600; line-height: 1.2;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
            overflow: hidden; margin-bottom: 4px;
        }
        .compact-subtitle { font-size: 0.75rem; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .loading-cover {
            background: linear-gradient(45deg, var(--dark-blue), #2c2c2c);
            display: flex; align-items: center; justify-content: center;
            color: rgba(255,255,255,0.2); height: 100%;
        }

        .d-none { display: none !important; }
    </style>
</head>
<body>
    <div class="hero-section">
        <div class="container">
            <div class="row">
                <div class="col-12 text-center">
                    <h1 class="display-6 mb-3"><i class="fas fa-play-circle me-2"></i>D-TECH ANIME</h1>
                    <form id="searchForm" class="search-box">
                        <div class="input-group">
                            <input type="text" id="searchInput" class="form-control"
                                   placeholder="Search anime..." required autocomplete="off">
                            <button class="btn text-white" type="submit"><i class="fas fa-search"></i></button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <div class="container">

        <div id="statusAlert" class="alert alert-info d-none"></div>

        <!-- Fresh Episodes -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="d-flex justify-content-between align-items-end mb-2">
                    <h3 class="section-title m-0"><i class="fas fa-tv me-2"></i>Fresh Episodes</h3>
                    <div style="text-align: right;">
                        <small class="text-muted d-block" style="font-size: 0.7rem;" id="lastUpdated">Updates 24h</small>
                        <button class="btn btn-sm btn-outline-primary" style="font-size: 0.7rem; padding: 2px 6px;" onclick="forceRefresh()">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                </div>

                <div class="media-scroller" id="freshEpisodesContainer">
                    <!-- JS Injected -->
                    <div class="alert alert-info">Loading episodes...</div>
                </div>
            </div>
        </div>

        <!-- Popular Anime -->
        <div class="row mt-4">
            <div class="col-12">
                <h3 class="section-title"><i class="fas fa-fire me-2"></i>Popular Anime</h3>
                <div class="media-scroller" id="popularAnimeContainer">
                    <!-- JS Injected -->
                </div>
            </div>
        </div>
    </div>

    <div style="height: 50px;"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- 1. CONFIG & STATE ---
        const CACHE_KEY_FRESH = 'dtech_fresh_episodes';
        const CACHE_KEY_POPULAR = 'dtech_popular_anime';

        // --- 2. IMAGE LOADING (Kitsu API) ---
        const coverCache = new Map();

        async function getAnimeCover(animeName) {
            if (!animeName) return null;

            if (coverCache.has(animeName)) return coverCache.get(animeName);
            const cached = localStorage.getItem(`cover_${animeName}`);
            if (cached) { coverCache.set(animeName, cached); return cached; }

            try {
                // Rate limit protection - wait random time
                await new Promise(r => setTimeout(r, Math.random() * 500));

                const cleanName = animeName.replace(/[^\w\s]/gi, '').trim();
                const res = await fetch(`https://kitsu.io/api/edge/anime?filter[text]=${encodeURIComponent(cleanName)}&page[limit]=1`);

                if (!res.ok) throw new Error('Kitsu API Error');

                const data = await res.json();
                const attrs = data.data?.[0]?.attributes;
                const url = attrs?.posterImage?.medium || attrs?.posterImage?.original;

                if (url) {
                    coverCache.set(animeName, url);
                    localStorage.setItem(`cover_${animeName}`, url);
                    return url;
                }
            } catch (e) {
                console.warn(`Failed to fetch cover for ${animeName}`, e);
            }
            return null;
        }

        async function loadAllCoverImages() {
            const els = document.querySelectorAll('.loading-cover');
            // Process in smaller batches
            for (let i=0; i<els.length; i+=5) {
                const batch = Array.from(els).slice(i, i+5);
                await Promise.all(batch.map(async (el) => {
                    // Check if already replaced
                    if (el.tagName === 'IMG' || !el.parentNode) return;

                    const name = el.getAttribute('data-anime-name');
                    const url = await getAnimeCover(name);

                    if (url) {
                        const img = document.createElement('img');
                        img.src = url;
                        img.className = 'anime-cover';
                        img.alt = name;
                        // Replace the loading div with the image
                        if (el.parentNode) {
                            el.parentNode.replaceChild(img, el);
                        }
                    } else {
                        // Keep loading state but maybe change style to indicate no image?
                        // For now we keep the placeholder icon
                        el.style.backgroundColor = '#333';
                    }
                }));
            }
        }

        // --- 3. DATA LOADING ---

        async function loadPopularAnime() {
            try {
                const response = await fetch('data/popular.json');
                if (!response.ok) throw new Error('Popular JSON not found');

                const popularAnime = await response.json();

                const container = document.getElementById('popularAnimeContainer');
                if (popularAnime && popularAnime.length > 0) {
                    container.innerHTML = popularAnime.map(anime => `
                        <div class="anime-card-compact" onclick="window.location.href='episodes.html?id=${anime.id}&title=${encodeURIComponent(anime.title)}'">
                            <div class="cover-wrapper">
                                <div class="loading-cover" data-anime-name="${anime.title}">
                                    <i class="fas fa-film"></i>
                                </div>
                                <div class="play-overlay"><i class="fas fa-list fa-2x text-white"></i></div>
                            </div>
                            <div class="compact-title">${anime.title}</div>
                            <div class="compact-subtitle">Series</div>
                        </div>
                    `).join('');
                    loadAllCoverImages();
                } else {
                    container.innerHTML = '<div class="alert alert-warning">No popular anime found.</div>';
                }
            } catch (e) {
                console.error("Failed to load popular anime", e);
                document.getElementById('popularAnimeContainer').innerHTML = '<div class="text-muted">Could not load popular anime.</div>';
            }
        }

        function loadFreshEpisodes() {
            const cached = localStorage.getItem(CACHE_KEY_FRESH);
            const container = document.getElementById('freshEpisodesContainer');

            if (cached) {
                try {
                    const data = JSON.parse(cached);
                    // Check if data is stale (24h)
                    const now = new Date().getTime();
                    const diff = now - (data.timestamp || 0);

                    if (diff > 24 * 60 * 60 * 1000) {
                         console.log("Fresh episodes cache expired, refreshing...");
                         forceRefresh();
                    } else {
                        if (data.episodes && data.episodes.length > 0) {
                            document.getElementById('lastUpdated').innerText = new Date(data.timestamp).toLocaleString();
                            renderFreshEpisodes(data.episodes);
                            return;
                        }
                    }
                } catch (e) {
                    console.error("Cache corrupted", e);
                    localStorage.removeItem(CACHE_KEY_FRESH);
                }
            }

            // If no cache or empty
            container.innerHTML = '<div class="alert alert-info">Fetching updates...</div>';
            // Trigger refresh if we didn't just find valid cache
            forceRefresh();
        }

        function renderFreshEpisodes(episodes) {
            const container = document.getElementById('freshEpisodesContainer');
            if (!episodes || episodes.length === 0) {
                container.innerHTML = '<div class="alert alert-warning">No updates found.</div>';
                return;
            }

            container.innerHTML = episodes.map(episode => `
                <div class="anime-card-compact"
                     onclick="startWatch('${episode.anime_id}', '${episode.session_id}')">
                    <div class="cover-wrapper">
                        <div class="loading-cover" data-anime-name="${episode.anime_name}">
                            <i class="fas fa-play"></i>
                        </div>
                        <div class="play-overlay"><i class="fas fa-play-circle fa-2x text-white"></i></div>
                        <div class="overlay-ep"><span class="ep-badge">Ep ${episode.episode_number}</span></div>
                    </div>
                    <div class="compact-title">${episode.anime_name}</div>
                    <div class="compact-subtitle">${episode.episode_title}</div>
                </div>
            `).join('');
            loadAllCoverImages();
        }

        // --- 4. INTERACTION & BRIDGE ---

        function forceRefresh() {
            const alertBox = document.getElementById('statusAlert');
            alertBox.classList.remove('d-none');
            alertBox.innerText = "Scraping fresh episodes...";

            if (window.Android && window.Android.scrapeUpdates) {
                try {
                    window.Android.scrapeUpdates();
                } catch(e) {
                     console.error("Bridge call failed", e);
                     alertBox.innerText = "Error contacting app.";
                }
            } else {
                console.warn("Android interface not found");
                // For browser testing, maybe mock it or hide alert after timeout
                setTimeout(() => {
                    alertBox.classList.add('d-none');
                }, 2000);
            }
        }

        // Called by Android when scraping is done
        function onScrapeResult(type, jsonString) {
             console.log("Received scrape result: " + type);
             if (type === 'fresh_episodes') {
                 onEpisodesFound(jsonString);
             }
        }

        function onEpisodesFound(jsonString) {
            console.log("Episodes found!");
            document.getElementById('statusAlert').classList.add('d-none');
            try {
                const result = JSON.parse(jsonString);
                // Handle different potential structures
                // scraper.js returns { status: "SUCCESS", data: [...] }
                let episodes = [];

                if (Array.isArray(result)) {
                    episodes = result;
                } else if (result.data && Array.isArray(result.data)) {
                    episodes = result.data;
                } else if (result.episodes && Array.isArray(result.episodes)) {
                    episodes = result.episodes;
                }

                if (episodes.length > 0) {
                    const data = {
                        timestamp: new Date().getTime(),
                        episodes: episodes
                    };
                    localStorage.setItem(CACHE_KEY_FRESH, JSON.stringify(data));
                    renderFreshEpisodes(episodes);
                } else {
                    console.warn("No episodes in payload", result);
                }
            } catch (e) {
                console.error("Error parsing episodes", e);
            }
        }

        // Expose globally
        window.onScrapeResult = onScrapeResult;
        window.onEpisodesFound = onEpisodesFound;

        function startWatch(animeId, sessionId) {
             window.location.href = `player.html?anime_id=${animeId}&video_url=${encodeURIComponent('https://animepahe.si/play/'+animeId+'/'+sessionId)}`;
        }

        // --- 5. INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            loadPopularAnime();
            loadFreshEpisodes();

            // Search Form
            const searchForm = document.getElementById('searchForm');
            if (searchForm) {
                searchForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const query = document.getElementById('searchInput').value;
                    if (query.trim()) {
                        window.location.href = `search.html?q=${encodeURIComponent(query)}`;
                    }
                });
            }
        });
    </script>
</body>
</html>
